diff --git a/gr-zeromq/examples/zmq_msg.grc b/gr-zeromq/examples/zmq_msg.grc
index cc1b71950..182ca0e20 100644
--- a/gr-zeromq/examples/zmq_msg.grc
+++ b/gr-zeromq/examples/zmq_msg.grc
@@ -24,6 +24,9 @@ options:
     title: ''
     window_size: 1280, 1024
   states:
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
     coordinate: [10, 10]
     rotation: 0
     state: enabled
@@ -36,7 +39,10 @@ blocks:
     alias: ''
     comment: ''
   states:
-    coordinate: [944, 112]
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
+    coordinate: [1224, 184.0]
     rotation: 0
     state: enabled
 - name: blocks_message_strobe_random_0
@@ -52,6 +58,9 @@ blocks:
     msg: pmt.intern("TEST")
     std: '0'
   states:
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
     coordinate: [216, 83]
     rotation: 0
     state: enabled
@@ -61,10 +70,32 @@ blocks:
     address: tcp://127.0.0.1:5555
     affinity: ''
     alias: ''
+    bind: 'True'
     comment: ''
+    key: ivana
     timeout: '100'
   states:
-    coordinate: [480, 99]
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
+    coordinate: [488, 60.0]
+    rotation: 0
+    state: enabled
+- name: zeromq_pub_msg_sink_0_0
+  id: zeromq_pub_msg_sink
+  parameters:
+    address: tcp://127.0.0.1:5555
+    affinity: ''
+    alias: ''
+    bind: 'True'
+    comment: ''
+    key: '9'
+    timeout: '100'
+  states:
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
+    coordinate: [560, 588.0]
     rotation: 0
     state: disabled
 - name: zeromq_pull_msg_source_0
@@ -73,11 +104,15 @@ blocks:
     address: tcp://127.0.0.1:5556
     affinity: ''
     alias: ''
+    bind: 'False'
     comment: ''
     maxoutbuf: '0'
     minoutbuf: '0'
     timeout: '100'
   states:
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
     coordinate: [656, 243]
     rotation: 0
     state: disabled
@@ -87,9 +122,13 @@ blocks:
     address: tcp://127.0.0.1:5556
     affinity: ''
     alias: ''
+    bind: 'True'
     comment: ''
     timeout: '100'
   states:
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
     coordinate: [480, 243]
     rotation: 0
     state: disabled
@@ -99,57 +138,76 @@ blocks:
     address: tcp://127.0.0.1:5557
     affinity: ''
     alias: ''
+    bind: 'True'
     comment: ''
     timeout: '100'
   states:
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
     coordinate: [480, 323]
     rotation: 0
-    state: enabled
+    state: disabled
 - name: zeromq_req_msg_source_0
   id: zeromq_req_msg_source
   parameters:
     address: tcp://127.0.0.1:5557
     affinity: ''
     alias: ''
+    bind: 'False'
     comment: ''
     maxoutbuf: '0'
     minoutbuf: '0'
     timeout: '100'
   states:
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
     coordinate: [656, 323]
     rotation: 0
-    state: enabled
+    state: disabled
 - name: zeromq_sub_msg_source_0
   id: zeromq_sub_msg_source
   parameters:
     address: tcp://127.0.0.1:5555
     affinity: ''
     alias: ''
+    bind: 'False'
     comment: ''
+    key: ivana
     maxoutbuf: '0'
     minoutbuf: '0'
     timeout: '100'
   states:
-    coordinate: [656, 99]
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
+    coordinate: [680, 60.0]
     rotation: 0
-    state: disabled
+    state: enabled
 - name: zeromq_sub_msg_source_0_0
   id: zeromq_sub_msg_source
   parameters:
     address: tcp://127.0.0.1:5555
     affinity: ''
     alias: ''
+    bind: 'False'
     comment: ''
+    key: ''
     maxoutbuf: '0'
     minoutbuf: '0'
     timeout: '100'
   states:
+    bus_sink: false
+    bus_source: false
+    bus_structure: null
     coordinate: [656, 163]
     rotation: 0
     state: disabled
 
 connections:
 - [blocks_message_strobe_random_0, strobe, zeromq_pub_msg_sink_0, in]
+- [blocks_message_strobe_random_0, strobe, zeromq_pub_msg_sink_0_0, in]
 - [blocks_message_strobe_random_0, strobe, zeromq_push_msg_sink_0, in]
 - [blocks_message_strobe_random_0, strobe, zeromq_rep_msg_sink_0, in]
 - [zeromq_pull_msg_source_0, out, blocks_message_debug_0, print]
diff --git a/gr-zeromq/grc/zeromq_pub_msg_sink.block.yml b/gr-zeromq/grc/zeromq_pub_msg_sink.block.yml
index 65b8cadb5..9a3e4e576 100644
--- a/gr-zeromq/grc/zeromq_pub_msg_sink.block.yml
+++ b/gr-zeromq/grc/zeromq_pub_msg_sink.block.yml
@@ -16,6 +16,10 @@ parameters:
     dtype: bool
     default: 'True'
     hide: part
+-   id: key
+    label: Filter Key
+    dtype: string
+    default: ''
 
 inputs:
 -   domain: message
@@ -24,6 +28,6 @@ inputs:
 
 templates:
     imports: from gnuradio import zeromq
-    make: zeromq.pub_msg_sink(${address}, ${timeout}, ${bind})
-    
+    make: zeromq.pub_msg_sink(${address}, ${timeout}, ${bind}, ${key})
+
 file_format: 1
diff --git a/gr-zeromq/grc/zeromq_pub_sink.block.yml b/gr-zeromq/grc/zeromq_pub_sink.block.yml
index d8e5983d2..10bd29b2f 100644
--- a/gr-zeromq/grc/zeromq_pub_sink.block.yml
+++ b/gr-zeromq/grc/zeromq_pub_sink.block.yml
@@ -34,6 +34,10 @@ parameters:
     dtype: int
     default: '-1'
     hide: ${ ('part' if hwm == -1 else 'none') }
+-   id: key
+    label: Filter Key
+    dtype: string
+    default: ''
 
 inputs:
 -   domain: stream
@@ -43,6 +47,6 @@ inputs:
 templates:
     imports: from gnuradio import zeromq
     make: zeromq.pub_sink(${type.itemsize}, ${vlen}, ${address}, ${timeout}, ${pass_tags},
-        ${hwm})
+        ${hwm}, ${key})
         
 file_format: 1
diff --git a/gr-zeromq/grc/zeromq_sub_msg_source.block.yml b/gr-zeromq/grc/zeromq_sub_msg_source.block.yml
index 8dde1520e..4fe4b3411 100644
--- a/gr-zeromq/grc/zeromq_sub_msg_source.block.yml
+++ b/gr-zeromq/grc/zeromq_sub_msg_source.block.yml
@@ -16,6 +16,10 @@ parameters:
     dtype: bool
     default: 'False'
     hide: part
+-   id: key
+    label: Filter Key
+    dtype: string
+    default: ''
 
 outputs:
 -   domain: message
@@ -24,6 +28,6 @@ outputs:
 
 templates:
     imports: from gnuradio import zeromq
-    make: zeromq.sub_msg_source(${address}, ${timeout}, ${bind})
+    make: zeromq.sub_msg_source(${address}, ${timeout}, ${bind}, ${key})
 
 file_format: 1
diff --git a/gr-zeromq/grc/zeromq_sub_source.block.yml b/gr-zeromq/grc/zeromq_sub_source.block.yml
index 7235d480f..e2f47e6e0 100644
--- a/gr-zeromq/grc/zeromq_sub_source.block.yml
+++ b/gr-zeromq/grc/zeromq_sub_source.block.yml
@@ -34,6 +34,10 @@ parameters:
     dtype: int
     default: '-1'
     hide: ${ ('part' if hwm == -1 else 'none') }
+-   id: key
+    label: Filter Key
+    dtype: string
+    default: ''
 
 outputs:
 -   domain: stream
@@ -43,6 +47,6 @@ outputs:
 templates:
     imports: from gnuradio import zeromq
     make: zeromq.sub_source(${type.itemsize}, ${vlen}, ${address}, ${timeout}, ${pass_tags},
-        ${hwm})
+        ${hwm}, ${key})
 
 file_format: 1
diff --git a/gr-zeromq/include/gnuradio/zeromq/pub_msg_sink.h b/gr-zeromq/include/gnuradio/zeromq/pub_msg_sink.h
index b52c4a42e..1969e9969 100644
--- a/gr-zeromq/include/gnuradio/zeromq/pub_msg_sink.h
+++ b/gr-zeromq/include/gnuradio/zeromq/pub_msg_sink.h
@@ -52,9 +52,9 @@ public:
      * \param timeout  Receive timeout in milliseconds, default is 100ms, 1us increments
      * \param bind     If true this block will bind to the address, otherwise it will
      * connect; the default is to bind
-     *
+     * \param key Prepend a key/topic to the start of each message (default is none)
      */
-    static sptr make(char* address, int timeout = 100, bool bind = true);
+    static sptr make(char* address, int timeout = 100, bool bind = true, const std::string& key = "");
 
     /*!
      * \brief Return a std::string of ZMQ_LAST_ENDPOINT from the underlying ZMQ socket.
diff --git a/gr-zeromq/include/gnuradio/zeromq/pub_sink.h b/gr-zeromq/include/gnuradio/zeromq/pub_sink.h
index 5e4c36c74..d62c878b9 100644
--- a/gr-zeromq/include/gnuradio/zeromq/pub_sink.h
+++ b/gr-zeromq/include/gnuradio/zeromq/pub_sink.h
@@ -54,13 +54,15 @@ public:
      * \param timeout  Receive timeout in milliseconds, default is 100ms, 1us increments.
      * \param pass_tags Whether sink will serialize and pass tags over the link.
      * \param hwm High Watermark to configure the socket to (-1 => zmq's default)
+     * \param key Prepend a key/topic to the start of each message (default is none)
      */
     static sptr make(size_t itemsize,
                      size_t vlen,
                      char* address,
                      int timeout = 100,
                      bool pass_tags = false,
-                     int hwm = -1);
+                     int hwm = -1,
+                     const std::string& key = "");
 
     /*!
      * \brief Return a std::string of ZMQ_LAST_ENDPOINT from the underlying ZMQ socket.
diff --git a/gr-zeromq/include/gnuradio/zeromq/sub_msg_source.h b/gr-zeromq/include/gnuradio/zeromq/sub_msg_source.h
index 09a47c6b0..f260b1962 100644
--- a/gr-zeromq/include/gnuradio/zeromq/sub_msg_source.h
+++ b/gr-zeromq/include/gnuradio/zeromq/sub_msg_source.h
@@ -49,10 +49,9 @@ public:
      * \param timeout  Receive timeout in milliseconds, default is 100ms, 1us increments
      * \param bind     If true this block will bind to the address, otherwise it will
      * connect; the default is to connect
-     *
+     * \param key Subscriber filter key. Leave empty to pass all messages.
      */
-    static sptr make(char* address, int timeout = 100, bool bind = false);
-
+    static sptr make(char* address, int timeout = 100, bool bind = false, const std::string& key = "");
     /*!
      * \brief Return a std::string of ZMQ_LAST_ENDPOINT from the underlying ZMQ socket.
      */
diff --git a/gr-zeromq/include/gnuradio/zeromq/sub_source.h b/gr-zeromq/include/gnuradio/zeromq/sub_source.h
index dc0014edb..9b6c32cb7 100644
--- a/gr-zeromq/include/gnuradio/zeromq/sub_source.h
+++ b/gr-zeromq/include/gnuradio/zeromq/sub_source.h
@@ -51,13 +51,15 @@ public:
      * \param timeout  Receive timeout in milliseconds, default is 100ms, 1us increments.
      * \param pass_tags Whether source will look for and deserialize tags.
      * \param hwm High Watermark to configure the socket to (-1 => zmq's default)
+     * \param key Subscriber filter key. Leave empty to pass all messages.
      */
     static sptr make(size_t itemsize,
                      size_t vlen,
                      char* address,
                      int timeout = 100,
                      bool pass_tags = false,
-                     int hwm = -1);
+                     int hwm = -1,
+                     const std::string& key = "");
 
     /*!
      * \brief Return a std::string of ZMQ_LAST_ENDPOINT from the underlying ZMQ socket.
diff --git a/gr-zeromq/lib/base_impl.cc b/gr-zeromq/lib/base_impl.cc
index e6100a8ef..3a8cfcfb8 100644
--- a/gr-zeromq/lib/base_impl.cc
+++ b/gr-zeromq/lib/base_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -35,8 +23,18 @@ constexpr int LINGER_DEFAULT = 1000; // 1 second.
 namespace gr {
 namespace zeromq {
 
-base_impl::base_impl(int type, size_t itemsize, size_t vlen, int timeout, bool pass_tags)
-    : d_vsize(itemsize * vlen), d_timeout(timeout), d_pass_tags(pass_tags)
+base_impl::base_impl(int type,
+                     size_t itemsize,
+                     size_t vlen,
+                     int timeout,
+                     bool pass_tags,
+                     const std::string& key)
+    : d_context(1),
+      d_socket(d_context, type),
+      d_vsize(itemsize * vlen),
+      d_timeout(timeout),
+      d_pass_tags(pass_tags),
+      d_key(key)
 {
     /* "Fix" timeout value (ms for new API, us for old API) */
     int major, minor, patch;
@@ -45,24 +43,15 @@ base_impl::base_impl(int type, size_t itemsize, size_t vlen, int timeout, bool p
     if (major < 3) {
         d_timeout *= 1000;
     }
-
-    /* Create context & socket */
-    d_context = new zmq::context_t(1);
-    d_socket = new zmq::socket_t(*d_context, type);
 }
 
-base_impl::~base_impl()
-{
-    d_socket->close();
-    delete d_socket;
-    delete d_context;
-}
+base_impl::~base_impl() {}
 
 std::string base_impl::last_endpoint()
 {
     char addr[256];
     size_t addr_len = sizeof(addr);
-    d_socket->getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
+    d_socket.getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
     return std::string(addr, addr_len - 1);
 }
 
@@ -73,30 +62,41 @@ base_sink_impl::base_sink_impl(int type,
                                char* address,
                                int timeout,
                                bool pass_tags,
-                               int hwm)
-    : base_impl(type, itemsize, vlen, timeout, pass_tags)
+                               int hwm,
+                               const std::string& key)
+    : base_impl(type, itemsize, vlen, timeout, pass_tags, key)
 {
     /* Set high watermark */
     if (hwm >= 0) {
 #ifdef ZMQ_SNDHWM
-        d_socket->setsockopt(ZMQ_SNDHWM, &hwm, sizeof(hwm));
+        d_socket.setsockopt(ZMQ_SNDHWM, &hwm, sizeof(hwm));
 #else // major < 3
         uint64_t tmp = hwm;
-        d_socket->setsockopt(ZMQ_HWM, &tmp, sizeof(tmp));
+        d_socket.setsockopt(ZMQ_HWM, &tmp, sizeof(tmp));
 #endif
     }
 
     /* Set ZMQ_LINGER so socket won't infinitely block during teardown */
-    d_socket->setsockopt(ZMQ_LINGER, &LINGER_DEFAULT, sizeof(LINGER_DEFAULT));
+    d_socket.setsockopt(ZMQ_LINGER, &LINGER_DEFAULT, sizeof(LINGER_DEFAULT));
 
     /* Bind */
-    d_socket->bind(address);
+    d_socket.bind(address);
 }
 
 int base_sink_impl::send_message(const void* in_buf,
                                  const int in_nitems,
                                  const uint64_t in_offset)
 {
+    /* Send key if it exists */
+    if (!d_key.empty()) {
+        zmq::message_t key_message(d_key.size());
+        memcpy(key_message.data(), d_key.data(), d_key.size());
+#if USE_NEW_CPPZMQ_SEND_RECV
+        d_socket.send(key_message, zmq::send_flags::sndmore);
+#else
+        d_socket.send(key_message, ZMQ_SNDMORE);
+#endif
+    }
     /* Meta-data header */
     std::string header("");
     if (d_pass_tags) {
@@ -119,9 +119,9 @@ int base_sink_impl::send_message(const void* in_buf,
 
     /* Send */
 #if USE_NEW_CPPZMQ_SEND_RECV
-    d_socket->send(msg, zmq::send_flags::none);
+    d_socket.send(msg, zmq::send_flags::none);
 #else
-    d_socket->send(msg);
+    d_socket.send(msg);
 #endif
 
     /* Report back */
@@ -134,26 +134,27 @@ base_source_impl::base_source_impl(int type,
                                    char* address,
                                    int timeout,
                                    bool pass_tags,
-                                   int hwm)
-    : base_impl(type, itemsize, vlen, timeout, pass_tags),
+                                   int hwm,
+                                   const std::string& key)
+    : base_impl(type, itemsize, vlen, timeout, pass_tags, key),
       d_consumed_bytes(0),
       d_consumed_items(0)
 {
     /* Set high watermark */
     if (hwm >= 0) {
 #ifdef ZMQ_RCVHWM
-        d_socket->setsockopt(ZMQ_RCVHWM, &hwm, sizeof(hwm));
+        d_socket.setsockopt(ZMQ_RCVHWM, &hwm, sizeof(hwm));
 #else // major < 3
         uint64_t tmp = hwm;
-        d_socket->setsockopt(ZMQ_HWM, &tmp, sizeof(tmp));
+        d_socket.setsockopt(ZMQ_HWM, &tmp, sizeof(tmp));
 #endif
     }
 
     /* Set ZMQ_LINGER so socket won't infinitely block during teardown */
-    d_socket->setsockopt(ZMQ_LINGER, &LINGER_DEFAULT, sizeof(LINGER_DEFAULT));
+    d_socket.setsockopt(ZMQ_LINGER, &LINGER_DEFAULT, sizeof(LINGER_DEFAULT));
 
     /* Connect */
-    d_socket->connect(address);
+    d_socket.connect(address);
 }
 
 bool base_source_impl::has_pending() { return d_msg.size() > d_consumed_bytes; }
@@ -190,7 +191,7 @@ int base_source_impl::flush_pending(void* out_buf,
 bool base_source_impl::load_message(bool wait)
 {
     /* Poll for input */
-    zmq::pollitem_t items[] = { { static_cast<void*>(*d_socket), 0, ZMQ_POLLIN, 0 } };
+    zmq::pollitem_t items[] = { { static_cast<void*>(d_socket), 0, ZMQ_POLLIN, 0 } };
     zmq::poll(&items[0], 1, wait ? d_timeout : 0);
 
     if (!(items[0].revents & ZMQ_POLLIN))
@@ -199,7 +200,7 @@ bool base_source_impl::load_message(bool wait)
     /* Is this the start or continuation of a multi-part message? */
     int64_t more = 0;
     size_t more_len = sizeof(more);
-    d_socket->getsockopt(ZMQ_RCVMORE, &more, &more_len);
+    d_socket.getsockopt(ZMQ_RCVMORE, &more, &more_len);
 
     /* Reset */
     d_msg.rebuild();
@@ -209,11 +210,37 @@ bool base_source_impl::load_message(bool wait)
 
     /* Get the message */
 #if USE_NEW_CPPZMQ_SEND_RECV
-    d_socket->recv(d_msg);
+    const bool ok = bool(d_socket.recv(d_msg));
 #else
-    d_socket->recv(&d_msg);
+    const bool ok = d_socket.recv(&d_msg);
 #endif
+    if (!ok) {
+        // This shouldn't happen since we polled POLLIN, but ZMQ wants us to check
+        // the return value.
+        GR_LOG_WARN(d_logger, "Failed to recv() message.");
+        return false;
+    }
+
+    /* Throw away key and get the first message. Avoid blocking if a multi-part
+     * message is not sent */
+    if (!d_key.empty() && !more) {
+        int64_t is_multipart;
+        d_socket.getsockopt(ZMQ_RCVMORE, &is_multipart, &more_len);
 
+        d_msg.rebuild();
+        if (is_multipart) {
+#if USE_NEW_CPPZMQ_SEND_RECV
+            const bool multi_ok = bool(d_socket.recv(d_msg));
+#else
+            const bool multi_ok = d_socket.recv(&d_msg);
+#endif
+            if (!multi_ok) {
+                GR_LOG_ERROR(d_logger, "Failure to receive multi-part message.");
+            }
+        } else {
+            return false;
+        }
+    }
     /* Parse header from the first (or only) message of a multi-part message */
     if (d_pass_tags && !more) {
         uint64_t rcv_offset;
@@ -229,10 +256,8 @@ bool base_source_impl::load_message(bool wait)
 
     /* Each message must contain an integer multiple of data vectors */
     if ((d_msg.size() - d_consumed_bytes) % d_vsize != 0) {
-        throw std::runtime_error(
-            boost::str(boost::format("Incompatible vector sizes: "
-                                     "need a multiple of %1% bytes per message") %
-                       d_vsize));
+        throw std::runtime_error("Incompatible vector sizes: need a multiple of " +
+                                 std::to_string(d_vsize) + " bytes per message");
     }
 
     /* We got one ! */
@@ -241,5 +266,3 @@ bool base_source_impl::load_message(bool wait)
 
 } /* namespace zeromq */
 } /* namespace gr */
-
-// vim: ts=2 sw=2 expandtab
diff --git a/gr-zeromq/lib/base_impl.h b/gr-zeromq/lib/base_impl.h
index 62216cce4..66dee36a9 100644
--- a/gr-zeromq/lib/base_impl.h
+++ b/gr-zeromq/lib/base_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_BASE_IMPL_H
@@ -32,16 +20,22 @@ namespace zeromq {
 class base_impl : public virtual gr::sync_block
 {
 public:
-    base_impl(int type, size_t itemsize, size_t vlen, int timeout, bool pass_tags);
-    virtual ~base_impl();
+    base_impl(int type,
+              size_t itemsize,
+              size_t vlen,
+              int timeout,
+              bool pass_tags,
+              const std::string& key = "");
+    ~base_impl() override;
 
 protected:
     std::string last_endpoint();
-    zmq::context_t* d_context;
-    zmq::socket_t* d_socket;
+    zmq::context_t d_context;
+    zmq::socket_t d_socket;
     size_t d_vsize;
     int d_timeout;
     bool d_pass_tags;
+    const std::string d_key;
 };
 
 class base_sink_impl : public base_impl
@@ -53,7 +47,8 @@ public:
                    char* address,
                    int timeout,
                    bool pass_tags,
-                   int hwm);
+                   int hwm,
+                   const std::string& key = "");
 
 protected:
     int send_message(const void* in_buf, const int in_nitems, const uint64_t in_offset);
@@ -68,7 +63,8 @@ public:
                      char* address,
                      int timeout,
                      bool pass_tags,
-                     int hwm);
+                     int hwm,
+                     const std::string& key = "");
 
 protected:
     zmq::message_t d_msg;
diff --git a/gr-zeromq/lib/gnuradio-zeromq.rc.in b/gr-zeromq/lib/gnuradio-zeromq.rc.in
index 41a5e65e9..8314fa649 100644
--- a/gr-zeromq/lib/gnuradio-zeromq.rc.in
+++ b/gr-zeromq/lib/gnuradio-zeromq.rc.in
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio
  *
- * GNU Radio is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * GNU Radio is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with GNU Radio; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #include <afxres.h>
diff --git a/gr-zeromq/lib/pub_msg_sink_impl.cc b/gr-zeromq/lib/pub_msg_sink_impl.cc
index 3973b8f83..eaf3b32bd 100644
--- a/gr-zeromq/lib/pub_msg_sink_impl.cc
+++ b/gr-zeromq/lib/pub_msg_sink_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -31,16 +19,19 @@
 namespace gr {
 namespace zeromq {
 
-pub_msg_sink::sptr pub_msg_sink::make(char* address, int timeout, bool bind)
+pub_msg_sink::sptr pub_msg_sink::make(char* address, int timeout, bool bind, const std::string& key)
 {
-    return gnuradio::get_initial_sptr(new pub_msg_sink_impl(address, timeout, bind));
+    return gnuradio::get_initial_sptr(new pub_msg_sink_impl(address, timeout, bind, key));
 }
 
-pub_msg_sink_impl::pub_msg_sink_impl(char* address, int timeout, bool bind)
+pub_msg_sink_impl::pub_msg_sink_impl(char* address, int timeout, bool bind, const std::string& key)
     : gr::block("pub_msg_sink",
                 gr::io_signature::make(0, 0, 0),
                 gr::io_signature::make(0, 0, 0)),
-      d_timeout(timeout)
+      d_timeout(timeout),
+      d_context(1),
+      d_socket(d_context, ZMQ_PUB),
+      d_key(key)
 {
     int major, minor, patch;
     zmq::version(&major, &minor, &patch);
@@ -49,31 +40,34 @@ pub_msg_sink_impl::pub_msg_sink_impl(char* address, int timeout, bool bind)
         d_timeout = timeout * 1000;
     }
 
-    d_context = new zmq::context_t(1);
-    d_socket = new zmq::socket_t(*d_context, ZMQ_PUB);
-
     int time = 0;
-    d_socket->setsockopt(ZMQ_LINGER, &time, sizeof(time));
+    d_socket.setsockopt(ZMQ_LINGER, &time, sizeof(time));
 
     if (bind) {
-        d_socket->bind(address);
+        d_socket.bind(address);
     } else {
-        d_socket->connect(address);
+        d_socket.connect(address);
     }
 
     message_port_register_in(pmt::mp("in"));
     set_msg_handler(pmt::mp("in"), [this](pmt::pmt_t msg) { this->handler(msg); });
 }
 
-pub_msg_sink_impl::~pub_msg_sink_impl()
-{
-    d_socket->close();
-    delete d_socket;
-    delete d_context;
-}
+pub_msg_sink_impl::~pub_msg_sink_impl() {}
 
 void pub_msg_sink_impl::handler(pmt::pmt_t msg)
 {
+        /* Send key if it exists */
+    if (!d_key.empty()) {
+        zmq::message_t key_message(d_key.size());
+        memcpy(key_message.data(), d_key.data(), d_key.size());
+#if USE_NEW_CPPZMQ_SEND_RECV
+        d_socket.send(key_message, zmq::send_flags::sndmore);
+#else
+        d_socket.send(key_message, ZMQ_SNDMORE);
+#endif
+    }
+
     std::stringbuf sb("");
     pmt::serialize(msg, sb);
     std::string s = sb.str();
@@ -81,9 +75,9 @@ void pub_msg_sink_impl::handler(pmt::pmt_t msg)
 
     memcpy(zmsg.data(), s.c_str(), s.size());
 #if USE_NEW_CPPZMQ_SEND_RECV
-    d_socket->send(zmsg, zmq::send_flags::none);
+    d_socket.send(zmsg, zmq::send_flags::none);
 #else
-    d_socket->send(zmsg);
+    d_socket.send(zmsg);
 #endif
 }
 
diff --git a/gr-zeromq/lib/pub_msg_sink_impl.h b/gr-zeromq/lib/pub_msg_sink_impl.h
index 69ca7203e..6ebc0096e 100644
--- a/gr-zeromq/lib/pub_msg_sink_impl.h
+++ b/gr-zeromq/lib/pub_msg_sink_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_PUB_MSG_SINK_IMPL_H
@@ -33,19 +21,20 @@ class pub_msg_sink_impl : public pub_msg_sink
 {
 private:
     float d_timeout;
-    zmq::context_t* d_context;
-    zmq::socket_t* d_socket;
+    zmq::context_t d_context;
+    zmq::socket_t d_socket;
+    const std::string d_key;
 
 public:
-    pub_msg_sink_impl(char* address, int timeout, bool bind);
-    ~pub_msg_sink_impl();
+    pub_msg_sink_impl(char* address, int timeout, bool bind, const std::string& key);
+    ~pub_msg_sink_impl() override;
 
     void handler(pmt::pmt_t msg);
     std::string last_endpoint() override
     {
         char addr[256];
         size_t addr_len = sizeof(addr);
-        d_socket->getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
+        d_socket.getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
         return std::string(addr, addr_len - 1);
     }
 };
diff --git a/gr-zeromq/lib/pub_sink_impl.cc b/gr-zeromq/lib/pub_sink_impl.cc
index 6441e4b17..84a736415 100644
--- a/gr-zeromq/lib/pub_sink_impl.cc
+++ b/gr-zeromq/lib/pub_sink_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -31,19 +19,29 @@
 namespace gr {
 namespace zeromq {
 
-pub_sink::sptr pub_sink::make(
-    size_t itemsize, size_t vlen, char* address, int timeout, bool pass_tags, int hwm)
+pub_sink::sptr pub_sink::make(size_t itemsize,
+                              size_t vlen,
+                              char* address,
+                              int timeout,
+                              bool pass_tags,
+                              int hwm,
+                              const std::string& key)
 {
     return gnuradio::get_initial_sptr(
-        new pub_sink_impl(itemsize, vlen, address, timeout, pass_tags, hwm));
+        new pub_sink_impl(itemsize, vlen, address, timeout, pass_tags, hwm, key));
 }
 
-pub_sink_impl::pub_sink_impl(
-    size_t itemsize, size_t vlen, char* address, int timeout, bool pass_tags, int hwm)
+pub_sink_impl::pub_sink_impl(size_t itemsize,
+                             size_t vlen,
+                             char* address,
+                             int timeout,
+                             bool pass_tags,
+                             int hwm,
+                             const std::string& key)
     : gr::sync_block("pub_sink",
                      gr::io_signature::make(1, 1, itemsize * vlen),
                      gr::io_signature::make(0, 0, 0)),
-      base_sink_impl(ZMQ_PUB, itemsize, vlen, address, timeout, pass_tags, hwm)
+      base_sink_impl(ZMQ_PUB, itemsize, vlen, address, timeout, pass_tags, hwm, key)
 {
     /* All is delegated */
 }
diff --git a/gr-zeromq/lib/pub_sink_impl.h b/gr-zeromq/lib/pub_sink_impl.h
index b833b6be4..c97f6c40b 100644
--- a/gr-zeromq/lib/pub_sink_impl.h
+++ b/gr-zeromq/lib/pub_sink_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_PUB_SINK_IMPL_H
@@ -38,11 +26,12 @@ public:
                   char* address,
                   int timeout,
                   bool pass_tags,
-                  int hwm);
+                  int hwm,
+                  const std::string& key);
 
     int work(int noutput_items,
              gr_vector_const_void_star& input_items,
-             gr_vector_void_star& output_items);
+             gr_vector_void_star& output_items) override;
     std::string last_endpoint() override { return base_sink_impl::last_endpoint(); }
 };
 
diff --git a/gr-zeromq/lib/pull_msg_source_impl.cc b/gr-zeromq/lib/pull_msg_source_impl.cc
index 2830be0f4..5f421aa21 100644
--- a/gr-zeromq/lib/pull_msg_source_impl.cc
+++ b/gr-zeromq/lib/pull_msg_source_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -29,6 +17,9 @@
 #include <gnuradio/io_signature.h>
 #include <boost/date_time/posix_time/posix_time.hpp>
 #include <boost/thread/thread.hpp>
+#include <chrono>
+#include <memory>
+#include <thread>
 
 namespace gr {
 namespace zeromq {
@@ -43,6 +34,8 @@ pull_msg_source_impl::pull_msg_source_impl(char* address, int timeout, bool bind
                 gr::io_signature::make(0, 0, 0),
                 gr::io_signature::make(0, 0, 0)),
       d_timeout(timeout),
+      d_context(1),
+      d_socket(d_context, ZMQ_PULL),
       d_port(pmt::mp("out"))
 {
     int major, minor, patch;
@@ -52,27 +45,19 @@ pull_msg_source_impl::pull_msg_source_impl(char* address, int timeout, bool bind
         d_timeout = timeout * 1000;
     }
 
-    d_context = new zmq::context_t(1);
-    d_socket = new zmq::socket_t(*d_context, ZMQ_PULL);
-
     int time = 0;
-    d_socket->setsockopt(ZMQ_LINGER, &time, sizeof(time));
+    d_socket.setsockopt(ZMQ_LINGER, &time, sizeof(time));
 
     if (bind) {
-        d_socket->bind(address);
+        d_socket.bind(address);
     } else {
-        d_socket->connect(address);
+        d_socket.connect(address);
     }
 
     message_port_register_out(d_port);
 }
 
-pull_msg_source_impl::~pull_msg_source_impl()
-{
-    d_socket->close();
-    delete d_socket;
-    delete d_context;
-}
+pull_msg_source_impl::~pull_msg_source_impl() {}
 
 bool pull_msg_source_impl::start()
 {
@@ -92,7 +77,7 @@ void pull_msg_source_impl::readloop()
 {
     while (!d_finished) {
 
-        zmq::pollitem_t items[] = { { static_cast<void*>(*d_socket), 0, ZMQ_POLLIN, 0 } };
+        zmq::pollitem_t items[] = { { static_cast<void*>(d_socket), 0, ZMQ_POLLIN, 0 } };
         zmq::poll(&items[0], 1, d_timeout);
 
         //  If we got a reply, process
@@ -101,10 +86,16 @@ void pull_msg_source_impl::readloop()
             // Receive data
             zmq::message_t msg;
 #if USE_NEW_CPPZMQ_SEND_RECV
-            d_socket->recv(msg);
+            const bool ok = bool(d_socket.recv(msg));
 #else
-            d_socket->recv(&msg);
+            const bool ok = d_socket.recv(&msg);
 #endif
+            if (!ok) {
+                // Should not happen, we've checked POLLIN.
+                GR_LOG_ERROR(d_logger, "Failed to receive message.");
+                boost::this_thread::sleep(boost::posix_time::microseconds(100));
+                continue;
+            }
 
             std::string buf(static_cast<char*>(msg.data()), msg.size());
             std::stringbuf sb(buf);
diff --git a/gr-zeromq/lib/pull_msg_source_impl.h b/gr-zeromq/lib/pull_msg_source_impl.h
index c714c717d..a4dc38279 100644
--- a/gr-zeromq/lib/pull_msg_source_impl.h
+++ b/gr-zeromq/lib/pull_msg_source_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_PULL_MSG_SOURCE_IMPL_H
@@ -33,8 +21,8 @@ class pull_msg_source_impl : public pull_msg_source
 {
 private:
     int d_timeout; // microseconds, -1 is blocking
-    zmq::context_t* d_context;
-    zmq::socket_t* d_socket;
+    zmq::context_t d_context;
+    zmq::socket_t d_socket;
     boost::thread* d_thread;
     const pmt::pmt_t d_port;
 
@@ -44,16 +32,16 @@ public:
     bool d_finished;
 
     pull_msg_source_impl(char* address, int timeout, bool bind);
-    ~pull_msg_source_impl();
+    ~pull_msg_source_impl() override;
 
-    bool start();
-    bool stop();
+    bool start() override;
+    bool stop() override;
 
     std::string last_endpoint() override
     {
         char addr[256];
         size_t addr_len = sizeof(addr);
-        d_socket->getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
+        d_socket.getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
         return std::string(addr, addr_len - 1);
     }
 };
diff --git a/gr-zeromq/lib/pull_source_impl.cc b/gr-zeromq/lib/pull_source_impl.cc
index 413930b80..7d184eef3 100644
--- a/gr-zeromq/lib/pull_source_impl.cc
+++ b/gr-zeromq/lib/pull_source_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/gr-zeromq/lib/pull_source_impl.h b/gr-zeromq/lib/pull_source_impl.h
index 14bbadc14..e3e0bf049 100644
--- a/gr-zeromq/lib/pull_source_impl.h
+++ b/gr-zeromq/lib/pull_source_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_PULL_SOURCE_IMPL_H
@@ -42,7 +30,7 @@ public:
 
     int work(int noutput_items,
              gr_vector_const_void_star& input_items,
-             gr_vector_void_star& output_items);
+             gr_vector_void_star& output_items) override;
     std::string last_endpoint() override { return base_source_impl::last_endpoint(); }
 };
 
diff --git a/gr-zeromq/lib/push_msg_sink_impl.cc b/gr-zeromq/lib/push_msg_sink_impl.cc
index fee734753..2ba1e4bab 100644
--- a/gr-zeromq/lib/push_msg_sink_impl.cc
+++ b/gr-zeromq/lib/push_msg_sink_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -40,7 +28,9 @@ push_msg_sink_impl::push_msg_sink_impl(char* address, int timeout, bool bind)
     : gr::block("push_msg_sink",
                 gr::io_signature::make(0, 0, 0),
                 gr::io_signature::make(0, 0, 0)),
-      d_timeout(timeout)
+      d_timeout(timeout),
+      d_context(1),
+      d_socket(d_context, ZMQ_PUSH)
 {
     int major, minor, patch;
     zmq::version(&major, &minor, &patch);
@@ -49,28 +39,20 @@ push_msg_sink_impl::push_msg_sink_impl(char* address, int timeout, bool bind)
         d_timeout = timeout * 1000;
     }
 
-    d_context = new zmq::context_t(1);
-    d_socket = new zmq::socket_t(*d_context, ZMQ_PUSH);
-
     int time = 0;
-    d_socket->setsockopt(ZMQ_LINGER, &time, sizeof(time));
+    d_socket.setsockopt(ZMQ_LINGER, &time, sizeof(time));
 
     if (bind) {
-        d_socket->bind(address);
+        d_socket.bind(address);
     } else {
-        d_socket->connect(address);
+        d_socket.connect(address);
     }
 
     message_port_register_in(pmt::mp("in"));
     set_msg_handler(pmt::mp("in"), [this](pmt::pmt_t msg) { this->handler(msg); });
 }
 
-push_msg_sink_impl::~push_msg_sink_impl()
-{
-    d_socket->close();
-    delete d_socket;
-    delete d_context;
-}
+push_msg_sink_impl::~push_msg_sink_impl() {}
 
 void push_msg_sink_impl::handler(pmt::pmt_t msg)
 {
@@ -81,9 +63,9 @@ void push_msg_sink_impl::handler(pmt::pmt_t msg)
 
     memcpy(zmsg.data(), s.c_str(), s.size());
 #if USE_NEW_CPPZMQ_SEND_RECV
-    d_socket->send(zmsg, zmq::send_flags::none);
+    d_socket.send(zmsg, zmq::send_flags::none);
 #else
-    d_socket->send(zmsg);
+    d_socket.send(zmsg);
 #endif
 }
 
diff --git a/gr-zeromq/lib/push_msg_sink_impl.h b/gr-zeromq/lib/push_msg_sink_impl.h
index 64105ebf1..b70ec5949 100644
--- a/gr-zeromq/lib/push_msg_sink_impl.h
+++ b/gr-zeromq/lib/push_msg_sink_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_PUSH_MSG_SINK_IMPL_H
@@ -33,19 +21,19 @@ class push_msg_sink_impl : public push_msg_sink
 {
 private:
     float d_timeout;
-    zmq::context_t* d_context;
-    zmq::socket_t* d_socket;
+    zmq::context_t d_context;
+    zmq::socket_t d_socket;
 
 public:
     push_msg_sink_impl(char* address, int timeout, bool bind);
-    ~push_msg_sink_impl();
+    ~push_msg_sink_impl() override;
 
     void handler(pmt::pmt_t msg);
     std::string last_endpoint() override
     {
         char addr[256];
         size_t addr_len = sizeof(addr);
-        d_socket->getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
+        d_socket.getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
         return std::string(addr, addr_len - 1);
     }
 };
diff --git a/gr-zeromq/lib/push_sink_impl.cc b/gr-zeromq/lib/push_sink_impl.cc
index 04d3d110d..d4a901634 100644
--- a/gr-zeromq/lib/push_sink_impl.cc
+++ b/gr-zeromq/lib/push_sink_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -53,7 +41,7 @@ int push_sink_impl::work(int noutput_items,
                          gr_vector_void_star& output_items)
 {
     // Poll with a timeout (FIXME: scheduler can't wait for us)
-    zmq::pollitem_t itemsout[] = { { static_cast<void*>(*d_socket), 0, ZMQ_POLLOUT, 0 } };
+    zmq::pollitem_t itemsout[] = { { static_cast<void*>(d_socket), 0, ZMQ_POLLOUT, 0 } };
     zmq::poll(&itemsout[0], 1, d_timeout);
 
     // If we can send something, do it
diff --git a/gr-zeromq/lib/push_sink_impl.h b/gr-zeromq/lib/push_sink_impl.h
index 670087f6c..0d754562c 100644
--- a/gr-zeromq/lib/push_sink_impl.h
+++ b/gr-zeromq/lib/push_sink_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_PUSH_SINK_IMPL_H
@@ -42,7 +30,7 @@ public:
 
     int work(int noutput_items,
              gr_vector_const_void_star& input_items,
-             gr_vector_void_star& output_items);
+             gr_vector_void_star& output_items) override;
 
     std::string last_endpoint() override { return base_sink_impl::last_endpoint(); }
 };
diff --git a/gr-zeromq/lib/rep_msg_sink_impl.cc b/gr-zeromq/lib/rep_msg_sink_impl.cc
index 4c020d1ff..4c33674b7 100644
--- a/gr-zeromq/lib/rep_msg_sink_impl.cc
+++ b/gr-zeromq/lib/rep_msg_sink_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -27,6 +15,7 @@
 #include "rep_msg_sink_impl.h"
 #include "tag_headers.h"
 #include <gnuradio/io_signature.h>
+#include <memory>
 
 namespace gr {
 namespace zeromq {
@@ -41,6 +30,8 @@ rep_msg_sink_impl::rep_msg_sink_impl(char* address, int timeout, bool bind)
                 gr::io_signature::make(0, 0, 0),
                 gr::io_signature::make(0, 0, 0)),
       d_timeout(timeout),
+      d_context(1),
+      d_socket(d_context, ZMQ_REP),
       d_port(pmt::mp("in"))
 {
     int major, minor, patch;
@@ -50,27 +41,19 @@ rep_msg_sink_impl::rep_msg_sink_impl(char* address, int timeout, bool bind)
         d_timeout = timeout * 1000;
     }
 
-    d_context = new zmq::context_t(1);
-    d_socket = new zmq::socket_t(*d_context, ZMQ_REP);
-
     int time = 0;
-    d_socket->setsockopt(ZMQ_LINGER, &time, sizeof(time));
+    d_socket.setsockopt(ZMQ_LINGER, &time, sizeof(time));
 
     if (bind) {
-        d_socket->bind(address);
+        d_socket.bind(address);
     } else {
-        d_socket->connect(address);
+        d_socket.connect(address);
     }
 
     message_port_register_in(d_port);
 }
 
-rep_msg_sink_impl::~rep_msg_sink_impl()
-{
-    d_socket->close();
-    delete d_socket;
-    delete d_context;
-}
+rep_msg_sink_impl::~rep_msg_sink_impl() {}
 
 bool rep_msg_sink_impl::start()
 {
@@ -95,7 +78,7 @@ void rep_msg_sink_impl::readloop()
 
             // wait for query...
             zmq::pollitem_t items[] = {
-                { static_cast<void*>(*d_socket), 0, ZMQ_POLLIN, 0 }
+                { static_cast<void*>(d_socket), 0, ZMQ_POLLIN, 0 }
             };
             zmq::poll(&items[0], 1, d_timeout);
 
@@ -105,10 +88,15 @@ void rep_msg_sink_impl::readloop()
                 // receive data request
                 zmq::message_t request;
 #if USE_NEW_CPPZMQ_SEND_RECV
-                d_socket->recv(request);
+                const bool ok = bool(d_socket.recv(request));
 #else
-                d_socket->recv(&request);
+                const bool ok = d_socket.recv(&request);
 #endif
+                if (!ok) {
+                    // Should not happen, we've checked POLLIN.
+                    GR_LOG_ERROR(d_logger, "Failed to receive message.");
+                    break; // Fall back to re-check d_finished
+                }
 
                 int req_output_items = *(static_cast<int*>(request.data()));
                 if (req_output_items != 1)
@@ -123,9 +111,9 @@ void rep_msg_sink_impl::readloop()
                 zmq::message_t zmsg(s.size());
                 memcpy(zmsg.data(), s.c_str(), s.size());
 #if USE_NEW_CPPZMQ_SEND_RECV
-                d_socket->send(zmsg, zmq::send_flags::none);
+                d_socket.send(zmsg, zmq::send_flags::none);
 #else
-                d_socket->send(zmsg);
+                d_socket.send(zmsg);
 #endif
             } // if req
         }     // while !empty
diff --git a/gr-zeromq/lib/rep_msg_sink_impl.h b/gr-zeromq/lib/rep_msg_sink_impl.h
index bf4757f38..6d19bb4a4 100644
--- a/gr-zeromq/lib/rep_msg_sink_impl.h
+++ b/gr-zeromq/lib/rep_msg_sink_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_REP_MSG_SINK_IMPL_H
@@ -33,8 +21,8 @@ class rep_msg_sink_impl : public rep_msg_sink
 {
 private:
     int d_timeout;
-    zmq::context_t* d_context;
-    zmq::socket_t* d_socket;
+    zmq::context_t d_context;
+    zmq::socket_t d_socket;
     boost::thread* d_thread;
     bool d_finished;
 
@@ -44,16 +32,16 @@ private:
 
 public:
     rep_msg_sink_impl(char* address, int timeout, bool bind);
-    ~rep_msg_sink_impl();
+    ~rep_msg_sink_impl() override;
 
-    bool start();
-    bool stop();
+    bool start() override;
+    bool stop() override;
 
     std::string last_endpoint() override
     {
         char addr[256];
         size_t addr_len = sizeof(addr);
-        d_socket->getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
+        d_socket.getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
         return std::string(addr, addr_len - 1);
     }
 };
diff --git a/gr-zeromq/lib/rep_sink_impl.cc b/gr-zeromq/lib/rep_sink_impl.cc
index 8f22f151b..19f5b111f 100644
--- a/gr-zeromq/lib/rep_sink_impl.cc
+++ b/gr-zeromq/lib/rep_sink_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -61,7 +49,7 @@ int rep_sink_impl::work(int noutput_items,
         /* Wait for a small time (FIXME: scheduler can't wait for us) */
         /* We only wait if its the first iteration, for the others we'll
          * let the scheduler retry */
-        zmq::pollitem_t items[] = { { static_cast<void*>(*d_socket), 0, ZMQ_POLLIN, 0 } };
+        zmq::pollitem_t items[] = { { static_cast<void*>(d_socket), 0, ZMQ_POLLIN, 0 } };
         zmq::poll(&items[0], 1, first ? d_timeout : 0);
 
         /* If we don't have anything, we're done */
@@ -71,10 +59,15 @@ int rep_sink_impl::work(int noutput_items,
         /* Get and parse the request */
         zmq::message_t request;
 #if USE_NEW_CPPZMQ_SEND_RECV
-        d_socket->recv(request);
+        bool ok = bool(d_socket.recv(request));
 #else
-        d_socket->recv(&request);
+        bool ok = d_socket.recv(&request);
 #endif
+        if (!ok) {
+            // Should not happen, we've checked POLLIN.
+            GR_LOG_ERROR(d_logger, "Failed to receive message.");
+            break;
+        }
 
         int nitems_send = noutput_items - done;
         if (request.size() >= sizeof(uint32_t)) {
diff --git a/gr-zeromq/lib/rep_sink_impl.h b/gr-zeromq/lib/rep_sink_impl.h
index 3cca61db0..ec4ec87bc 100644
--- a/gr-zeromq/lib/rep_sink_impl.h
+++ b/gr-zeromq/lib/rep_sink_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_REP_SINK_IMPL_H
@@ -41,7 +29,7 @@ public:
 
     int work(int noutput_items,
              gr_vector_const_void_star& input_items,
-             gr_vector_void_star& output_items);
+             gr_vector_void_star& output_items) override;
     std::string last_endpoint() override { return base_sink_impl::last_endpoint(); }
 };
 
diff --git a/gr-zeromq/lib/req_msg_source_impl.cc b/gr-zeromq/lib/req_msg_source_impl.cc
index 362a183c1..11eb15482 100644
--- a/gr-zeromq/lib/req_msg_source_impl.cc
+++ b/gr-zeromq/lib/req_msg_source_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -29,6 +17,9 @@
 #include <gnuradio/io_signature.h>
 #include <boost/date_time/posix_time/posix_time.hpp>
 #include <boost/thread/thread.hpp>
+#include <chrono>
+#include <memory>
+#include <thread>
 
 namespace gr {
 namespace zeromq {
@@ -43,6 +34,8 @@ req_msg_source_impl::req_msg_source_impl(char* address, int timeout, bool bind)
                 gr::io_signature::make(0, 0, 0),
                 gr::io_signature::make(0, 0, 0)),
       d_timeout(timeout),
+      d_context(1),
+      d_socket(d_context, ZMQ_REQ),
       d_port(pmt::mp("out"))
 {
     int major, minor, patch;
@@ -52,27 +45,19 @@ req_msg_source_impl::req_msg_source_impl(char* address, int timeout, bool bind)
         d_timeout = timeout * 1000;
     }
 
-    d_context = new zmq::context_t(1);
-    d_socket = new zmq::socket_t(*d_context, ZMQ_REQ);
-
     int time = 0;
-    d_socket->setsockopt(ZMQ_LINGER, &time, sizeof(time));
+    d_socket.setsockopt(ZMQ_LINGER, &time, sizeof(time));
 
     if (bind) {
-        d_socket->bind(address);
+        d_socket.bind(address);
     } else {
-        d_socket->connect(address);
+        d_socket.connect(address);
     }
 
     message_port_register_out(d_port);
 }
 
-req_msg_source_impl::~req_msg_source_impl()
-{
-    d_socket->close();
-    delete d_socket;
-    delete d_context;
-}
+req_msg_source_impl::~req_msg_source_impl() {}
 
 bool req_msg_source_impl::start()
 {
@@ -94,7 +79,7 @@ void req_msg_source_impl::readloop()
         // std::cout << "readloop\n";
 
         zmq::pollitem_t itemsout[] = {
-            { static_cast<void*>(*d_socket), 0, ZMQ_POLLOUT, 0 }
+            { static_cast<void*>(d_socket), 0, ZMQ_POLLOUT, 0 }
         };
         zmq::poll(&itemsout[0], 1, d_timeout);
 
@@ -105,13 +90,13 @@ void req_msg_source_impl::readloop()
             zmq::message_t request(sizeof(int));
             memcpy((void*)request.data(), &nmsg, sizeof(int));
 #if USE_NEW_CPPZMQ_SEND_RECV
-            d_socket->send(request, zmq::send_flags::none);
+            d_socket.send(request, zmq::send_flags::none);
 #else
-            d_socket->send(request);
+            d_socket.send(request);
 #endif
         }
 
-        zmq::pollitem_t items[] = { { static_cast<void*>(*d_socket), 0, ZMQ_POLLIN, 0 } };
+        zmq::pollitem_t items[] = { { static_cast<void*>(d_socket), 0, ZMQ_POLLIN, 0 } };
         zmq::poll(&items[0], 1, d_timeout);
 
         //  If we got a reply, process
@@ -119,10 +104,16 @@ void req_msg_source_impl::readloop()
             // Receive data
             zmq::message_t msg;
 #if USE_NEW_CPPZMQ_SEND_RECV
-            d_socket->recv(msg);
+            const bool ok = bool(d_socket.recv(msg));
 #else
-            d_socket->recv(&msg);
+            const bool ok = d_socket.recv(&msg);
 #endif
+            if (!ok) {
+                // Should not happen, we've checked POLLIN.
+                GR_LOG_ERROR(d_logger, "Failed to receive message.");
+                boost::this_thread::sleep(boost::posix_time::microseconds(100));
+                continue;
+            }
 
             std::string buf(static_cast<char*>(msg.data()), msg.size());
             std::stringbuf sb(buf);
diff --git a/gr-zeromq/lib/req_msg_source_impl.h b/gr-zeromq/lib/req_msg_source_impl.h
index c863aa57d..d1635137f 100644
--- a/gr-zeromq/lib/req_msg_source_impl.h
+++ b/gr-zeromq/lib/req_msg_source_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_REQ_MSG_SOURCE_IMPL_H
@@ -33,8 +21,8 @@ class req_msg_source_impl : public req_msg_source
 {
 private:
     int d_timeout;
-    zmq::context_t* d_context;
-    zmq::socket_t* d_socket;
+    zmq::context_t d_context;
+    zmq::socket_t d_socket;
     boost::thread* d_thread;
     const pmt::pmt_t d_port;
 
@@ -44,16 +32,16 @@ public:
     bool d_finished;
 
     req_msg_source_impl(char* address, int timeout, bool bind);
-    ~req_msg_source_impl();
+    ~req_msg_source_impl() override;
 
-    bool start();
-    bool stop();
+    bool start() override;
+    bool stop() override;
 
     std::string last_endpoint() override
     {
         char addr[256];
         size_t addr_len = sizeof(addr);
-        d_socket->getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
+        d_socket.getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
         return std::string(addr, addr_len - 1);
     }
 };
diff --git a/gr-zeromq/lib/req_source_impl.cc b/gr-zeromq/lib/req_source_impl.cc
index f9f06362c..e79b7432e 100644
--- a/gr-zeromq/lib/req_source_impl.cc
+++ b/gr-zeromq/lib/req_source_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -78,9 +66,9 @@ int req_source_impl::work(int noutput_items,
                 zmq::message_t request(sizeof(uint32_t));
                 memcpy((void*)request.data(), &req_len, sizeof(uint32_t));
 #if USE_NEW_CPPZMQ_SEND_RECV
-                d_socket->send(request, zmq::send_flags::none);
+                d_socket.send(request, zmq::send_flags::none);
 #else
-                d_socket->send(request);
+                d_socket.send(request);
 #endif
 
                 d_req_pending = true;
diff --git a/gr-zeromq/lib/req_source_impl.h b/gr-zeromq/lib/req_source_impl.h
index f6438d878..c05cc5f40 100644
--- a/gr-zeromq/lib/req_source_impl.h
+++ b/gr-zeromq/lib/req_source_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_REQ_SOURCE_IMPL_H
@@ -42,7 +30,7 @@ public:
 
     int work(int noutput_items,
              gr_vector_const_void_star& input_items,
-             gr_vector_void_star& output_items);
+             gr_vector_void_star& output_items) override;
 
     std::string last_endpoint() override { return base_source_impl::last_endpoint(); }
 
diff --git a/gr-zeromq/lib/sub_msg_source_impl.cc b/gr-zeromq/lib/sub_msg_source_impl.cc
index 7bf22528f..c97c6eda3 100644
--- a/gr-zeromq/lib/sub_msg_source_impl.cc
+++ b/gr-zeromq/lib/sub_msg_source_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -27,23 +15,29 @@
 #include "sub_msg_source_impl.h"
 #include "tag_headers.h"
 #include <gnuradio/io_signature.h>
+#include <chrono>
+#include <memory>
+#include <thread>
 #include <boost/date_time/posix_time/posix_time.hpp>
 #include <boost/thread/thread.hpp>
 
 namespace gr {
 namespace zeromq {
 
-sub_msg_source::sptr sub_msg_source::make(char* address, int timeout, bool bind)
+sub_msg_source::sptr sub_msg_source::make(char* address, int timeout, bool bind, const std::string& key)
 {
-    return gnuradio::get_initial_sptr(new sub_msg_source_impl(address, timeout, bind));
+    return gnuradio::get_initial_sptr(new sub_msg_source_impl(address, timeout, bind, key));
 }
 
-sub_msg_source_impl::sub_msg_source_impl(char* address, int timeout, bool bind)
+sub_msg_source_impl::sub_msg_source_impl(char* address, int timeout, bool bind, const std::string& key)
     : gr::block("sub_msg_source",
                 gr::io_signature::make(0, 0, 0),
                 gr::io_signature::make(0, 0, 0)),
       d_timeout(timeout),
-      d_port(pmt::mp("out"))
+      d_context(1),
+      d_socket(d_context, ZMQ_SUB),
+      d_port(pmt::mp("out")),
+      d_key(key)
 {
     int major, minor, patch;
     zmq::version(&major, &minor, &patch);
@@ -51,27 +45,17 @@ sub_msg_source_impl::sub_msg_source_impl(char* address, int timeout, bool bind)
     if (major < 3) {
         d_timeout = timeout * 1000;
     }
-
-    d_context = new zmq::context_t(1);
-    d_socket = new zmq::socket_t(*d_context, ZMQ_SUB);
-
-    d_socket->setsockopt(ZMQ_SUBSCRIBE, "", 0);
-
+    d_socket.setsockopt(ZMQ_SUBSCRIBE, key.c_str(), key.length());
     if (bind) {
-        d_socket->bind(address);
+        d_socket.bind(address);
     } else {
-        d_socket->connect(address);
+        d_socket.connect(address);
     }
 
     message_port_register_out(d_port);
 }
 
-sub_msg_source_impl::~sub_msg_source_impl()
-{
-    d_socket->close();
-    delete d_socket;
-    delete d_context;
-}
+sub_msg_source_impl::~sub_msg_source_impl() {}
 
 bool sub_msg_source_impl::start()
 {
@@ -91,19 +75,52 @@ void sub_msg_source_impl::readloop()
 {
     while (!d_finished) {
 
-        zmq::pollitem_t items[] = { { static_cast<void*>(*d_socket), 0, ZMQ_POLLIN, 0 } };
+        zmq::pollitem_t items[] = { { static_cast<void*>(d_socket), 0, ZMQ_POLLIN, 0 } };
         zmq::poll(&items[0], 1, d_timeout);
 
         //  If we got a reply, process
         if (items[0].revents & ZMQ_POLLIN) {
 
+            /* Is this the start or continuation of a multi-part message? */
+            int64_t more = 0;
+            size_t more_len = sizeof(more);
+            d_socket.getsockopt(ZMQ_RCVMORE, &more, &more_len);
+
             // Receive data
             zmq::message_t msg;
 #if USE_NEW_CPPZMQ_SEND_RECV
-            d_socket->recv(msg);
+            const bool ok = bool(d_socket.recv(msg));
+#else
+            const bool ok = d_socket.recv(&msg);
+#endif
+            if (!ok) {
+                // Should not happen, we've checked POLLIN.
+                GR_LOG_ERROR(d_logger, "Failed to receive message.");
+                boost::this_thread::sleep(boost::posix_time::microseconds(100));
+                continue;
+            }
+            /* Throw away key and get the first message. Avoid blocking if a multi-part
+             * message is not sent */
+            if (!d_key.empty() && !more) {
+                int64_t is_multipart;
+                d_socket.getsockopt(ZMQ_RCVMORE, &is_multipart, &more_len);
+
+                msg.rebuild();
+                if (is_multipart) {
+#if USE_NEW_CPPZMQ_SEND_RECV
+                    const bool multi_ok = bool(d_socket.recv(msg));
 #else
-            d_socket->recv(&msg);
+                    const bool multi_ok = d_socket.recv(&msg);
 #endif
+                    if (!multi_ok) {
+                        GR_LOG_ERROR(d_logger, "Failure to receive multi-part message.");
+                        boost::this_thread::sleep(boost::posix_time::microseconds(100));
+                        continue;
+                    }
+                } else {
+                    boost::this_thread::sleep(boost::posix_time::microseconds(100));
+                }
+            }
             std::string buf(static_cast<char*>(msg.data()), msg.size());
             std::stringbuf sb(buf);
             try {
diff --git a/gr-zeromq/lib/sub_msg_source_impl.h b/gr-zeromq/lib/sub_msg_source_impl.h
index 50f7beb3c..adb0d6c91 100644
--- a/gr-zeromq/lib/sub_msg_source_impl.h
+++ b/gr-zeromq/lib/sub_msg_source_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_SUB_MSG_SOURCE_IMPL_H
@@ -33,27 +21,28 @@ class sub_msg_source_impl : public sub_msg_source
 {
 private:
     int d_timeout; // microseconds, -1 is blocking
-    zmq::context_t* d_context;
-    zmq::socket_t* d_socket;
+    zmq::context_t d_context;
+    zmq::socket_t d_socket;
     boost::thread* d_thread;
     const pmt::pmt_t d_port;
+    const std::string d_key;
 
     void readloop();
 
 public:
     bool d_finished;
 
-    sub_msg_source_impl(char* address, int timeout, bool bind);
-    ~sub_msg_source_impl();
+    sub_msg_source_impl(char* address, int timeout, bool bind, const std::string& key);
+    ~sub_msg_source_impl() override;
 
-    bool start();
-    bool stop();
+    bool start() override;
+    bool stop() override;
 
     std::string last_endpoint() override
     {
         char addr[256];
         size_t addr_len = sizeof(addr);
-        d_socket->getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
+        d_socket.getsockopt(ZMQ_LAST_ENDPOINT, addr, &addr_len);
         return std::string(addr, addr_len - 1);
     }
 };
diff --git a/gr-zeromq/lib/sub_source_impl.cc b/gr-zeromq/lib/sub_source_impl.cc
index fe0878013..4c82c18f3 100644
--- a/gr-zeromq/lib/sub_source_impl.cc
+++ b/gr-zeromq/lib/sub_source_impl.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -31,22 +19,32 @@
 namespace gr {
 namespace zeromq {
 
-sub_source::sptr sub_source::make(
-    size_t itemsize, size_t vlen, char* address, int timeout, bool pass_tags, int hwm)
+sub_source::sptr sub_source::make(size_t itemsize,
+                                  size_t vlen,
+                                  char* address,
+                                  int timeout,
+                                  bool pass_tags,
+                                  int hwm,
+                                  const std::string& key)
 {
     return gnuradio::get_initial_sptr(
-        new sub_source_impl(itemsize, vlen, address, timeout, pass_tags, hwm));
+        new sub_source_impl(itemsize, vlen, address, timeout, pass_tags, hwm, key));
 }
 
-sub_source_impl::sub_source_impl(
-    size_t itemsize, size_t vlen, char* address, int timeout, bool pass_tags, int hwm)
+sub_source_impl::sub_source_impl(size_t itemsize,
+                                 size_t vlen,
+                                 char* address,
+                                 int timeout,
+                                 bool pass_tags,
+                                 int hwm,
+                                 const std::string& key)
     : gr::sync_block("sub_source",
                      gr::io_signature::make(0, 0, 0),
                      gr::io_signature::make(1, 1, itemsize * vlen)),
-      base_source_impl(ZMQ_SUB, itemsize, vlen, address, timeout, pass_tags, hwm)
+      base_source_impl(ZMQ_SUB, itemsize, vlen, address, timeout, pass_tags, hwm, key)
 {
     /* Subscribe */
-    d_socket->setsockopt(ZMQ_SUBSCRIBE, "", 0);
+    d_socket.setsockopt(ZMQ_SUBSCRIBE, key.c_str(), key.size());
 }
 
 int sub_source_impl::work(int noutput_items,
diff --git a/gr-zeromq/lib/sub_source_impl.h b/gr-zeromq/lib/sub_source_impl.h
index 6f6012a4f..08221381b 100644
--- a/gr-zeromq/lib/sub_source_impl.h
+++ b/gr-zeromq/lib/sub_source_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_SUB_SOURCE_IMPL_H
@@ -38,11 +26,12 @@ public:
                     char* address,
                     int timeout,
                     bool pass_tags,
-                    int hwm);
+                    int hwm,
+                    const std::string& key);
 
     int work(int noutput_items,
              gr_vector_const_void_star& input_items,
-             gr_vector_void_star& output_items);
+             gr_vector_void_star& output_items) override;
 
     std::string last_endpoint() override { return base_source_impl::last_endpoint(); }
 };
diff --git a/gr-zeromq/lib/tag_headers.cc b/gr-zeromq/lib/tag_headers.cc
index 2d8971919..021da00db 100644
--- a/gr-zeromq/lib/tag_headers.cc
+++ b/gr-zeromq/lib/tag_headers.cc
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #include "zmq_common_impl.h"
diff --git a/gr-zeromq/lib/tag_headers.h b/gr-zeromq/lib/tag_headers.h
index c449f9cec..63451a8ce 100644
--- a/gr-zeromq/lib/tag_headers.h
+++ b/gr-zeromq/lib/tag_headers.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef ZEROMQ_TAG_HEADERS_H
diff --git a/gr-zeromq/lib/zmq_common_impl.h b/gr-zeromq/lib/zmq_common_impl.h
index 8fb934fbd..3281fb879 100644
--- a/gr-zeromq/lib/zmq_common_impl.h
+++ b/gr-zeromq/lib/zmq_common_impl.h
@@ -4,20 +4,8 @@
  *
  * This file is part of GNU Radio.
  *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 3, or (at your option)
- * any later version.
+ * SPDX-License-Identifier: GPL-3.0-or-later
  *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street,
- * Boston, MA 02110-1301, USA.
  */
 
 #ifndef INCLUDED_ZEROMQ_ZMQ_COMMON_IMPL_H
